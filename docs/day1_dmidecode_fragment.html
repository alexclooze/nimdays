<div id="cid1" data-tralics-id="cid1" class="chapter" data-number="1" data-chapter="day1_dmidecode"><h1><a href="day1_dmidecode_fragment.html#cid1" class="heading hyperref"><span class="number">Chapter 1 </span>Day 1: Parsing DMIDecode output</a></h1>
<p class="noindent">In our first day we will write a <a href="https://man.cx/?page=dmidecode(8)" target="_blank" rel="noopener">dmidecode</a> parser in nim</p>
</div><div id="cid2" data-tralics-id="cid2" class="section" data-number="1.1"><h2><a href="day1_dmidecode_fragment.html#cid2" class="heading hyperref"><span class="number">1.1 </span>What to expect ?</a></h2>
<p class="noindent"></p><div class="code"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">sample1</span> <span class="o">=</span> <span class="s">"""</span>
<span class="s"># dmidecode 3.1</span>
<span class="s">Getting SMBIOS data from sysfs.</span>
<span class="s">SMBIOS 2.6 present.</span>

<span class="s">Handle 0x0001, DMI type 1, 27 bytes</span>
<span class="s">System Information</span>
<span class="s">        Manufacturer: LENOVO</span>
<span class="s">        Product Name: 20042</span>
<span class="s">        Version: Lenovo G560</span>
<span class="s">        Serial Number: 2677240001087</span>
<span class="s">        UUID: CB3E6A50-A77B-E011-88E9-B870F4165734</span>
<span class="s">        Wake-up Type: Power Switch</span>
<span class="s">        SKU Number: Calpella_CRB</span>
<span class="s">        Family: Intel_Mobile</span>
<span class="s">"""</span>

<span class="kn">import</span> <span class="n">dmidecode</span><span class="p">,</span> <span class="n">tables</span>

<span class="kd">var</span> <span class="n">obj</span> <span class="p">:</span> <span class="n">Table</span><span class="o">[</span><span class="kt">string</span><span class="p">,</span> <span class="n">dmidecode</span><span class="p">.</span><span class="n">Section</span><span class="o">]</span>
<span class="n">obj</span> <span class="o">=</span> <span class="n">parseDMI</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span>
<span class="k">for</span> <span class="n">secname</span><span class="p">,</span> <span class="n">sec</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">:</span>
    <span class="n">echo</span> <span class="n">secname</span> <span class="o">&amp;</span> <span class="s">" with "</span> <span class="o">&amp;</span> <span class="o">$</span><span class="n">len</span><span class="p">(</span><span class="n">sec</span><span class="p">.</span><span class="n">props</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">sec</span><span class="p">.</span><span class="n">props</span><span class="p">:</span>
        <span class="n">echo</span> <span class="s">"k : "</span> <span class="o">&amp;</span> <span class="n">k</span> <span class="o">&amp;</span> <span class="s">" =&gt; "</span> <span class="o">&amp;</span> <span class="n">p</span><span class="p">.</span><span class="n">val</span> 
        <span class="k">if</span> <span class="n">len</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">items</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">p</span><span class="p">.</span><span class="n">items</span><span class="p">:</span>
                <span class="n">echo</span> <span class="s">"</span><span class="se">\t\t</span><span class="s"> I: "</span><span class="p">,</span> <span class="n">i</span>
</pre></div></div>
</div><div id="cid3" data-tralics-id="cid3" class="section" data-number="1.2"><h2><a href="day1_dmidecode_fragment.html#cid3" class="heading hyperref"><span class="number">1.2 </span>Implementation</a></h2>
<p class="noindent">a while ago at work (https://github.com/zero-os/0-core) we needed to parse some dmidecode output, and it sounds like an good problem with enough concepts to get my feet wet in nim.</p>
<div id="uid1" data-tralics-id="uid1" class="subsection" data-number="1.2.1"><h3><a href="day1_dmidecode_fragment.html#uid1" class="heading hyperref"><span class="number">1.2.1 </span>nimble ready!</a></h3>
<p class="noindent"></p><div class="code"><div class="highlight"><pre><span></span>mkdir dmidecode
nimble init
</pre></div></div>
</div>
<div id="uid2" data-tralics-id="uid2" class="subsection" data-number="1.2.2"><h3><a href="day1_dmidecode_fragment.html#uid2" class="heading hyperref"><span class="number">1.2.2 </span>So how does dmidecode output look like?</a></h3>
<p class="noindent"></p><div class="code"><div class="highlight"><pre><span></span># dmidecode 3.1
Getting SMBIOS data from sysfs.
SMBIOS 2.6 present.

Handle 0x0001, DMI type 1, 27 bytes
System Information
        Manufacturer: LENOVO
        Product Name: 20042
        Version: Lenovo G560
        Serial Number: 2677240001087
        UUID: CB3E6A50-A77B-E011-88E9-B870F4165734
        Wake-up Type: Power Switch
        SKU Number: Calpella_CRB
        Family: Intel_Mobile
</pre></div></div>
<p>or</p>
<div class="code"><div class="highlight"><pre><span></span>Getting SMBIOS data from sysfs.
SMBIOS 2.6 present.

Handle 0x0000, DMI type 0, 24 bytes
BIOS Information
        Vendor: LENOVO
        Version: 29CN40WW(V2.17)
        Release Date: 04/13/2011
        ROM Size: 2048 kB
        Characteristics:
                PCI is supported
                BIOS is upgradeable
                BIOS shadowing is allowed
                Boot from CD is supported
                Selectable boot is supported
                EDD is supported
                Japanese floppy for NEC 9800 1.2 MB is supported (int 13h)
                Japanese floppy for Toshiba 1.2 MB is supported (int 13h)
                5.25"/360 kB floppy services are supported (int 13h)
                5.25"/1.2 MB floppy services are supported (int 13h)
                3.5"/720 kB floppy services are supported (int 13h)
                3.5"/2.88 MB floppy services are supported (int 13h)
                8042 keyboard services are supported (int 9h)
                CGA/mono video services are supported (int 10h)
                ACPI is supported
                USB legacy is supported
                BIOS boot specification is supported
                Targeted content distribution is supported
        BIOS Revision: 1.40
</pre></div></div>
<ul>
<li>DMIDecode output is some meta like comments, versions and one or more sections
</li>
<li>Section: consists of a
<ul>
<li>handle line
</li>
<li>title line
</li>
<li>one or more indented properties
</li></ul>
</li>
<li>Property: consists of
<ul>
<li>key
</li>
<li>optional value
</li>
<li>optional list of indented items
</li></ul>
</li></ul>
</div>
<div id="uid12" data-tralics-id="uid12" class="subsection" data-number="1.2.3"><h3><a href="day1_dmidecode_fragment.html#uid12" class="heading hyperref"><span class="number">1.2.3 </span>Mapping DMI to nim structures</a></h3>
<p class="noindent">So ourplan is to have an api like
</p><div class="code"><div class="highlight"><pre><span></span><span class="n">dmifile</span> <span class="o">=</span> <span class="n">parseDMI</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
<span class="n">dmifile</span><span class="o">[</span><span class="s">"section1"</span><span class="o">][</span><span class="s">"property1].value</span>
</pre></div></div>
<p>Let’s describe the document structure we have
</p><div class="code"><div class="highlight"><pre><span></span><span class="kn">import</span>  <span class="n">sequtils</span><span class="p">,</span> <span class="n">tables</span><span class="p">,</span> <span class="n">strutils</span>

<span class="k">type</span> 
    <span class="n">Property</span><span class="o">*</span> <span class="o">=</span> <span class="k">ref</span> <span class="k">object</span>
        <span class="n">val</span><span class="o">*</span><span class="p">:</span> <span class="kt">string</span>
        <span class="n">items</span><span class="o">*</span><span class="p">:</span> <span class="kt">seq</span><span class="o">[</span><span class="kt">string</span><span class="o">]</span>
<span class="k">type</span>
    <span class="n">Section</span><span class="o">*</span> <span class="o">=</span> <span class="k">ref</span> <span class="k">object</span>
        <span class="n">handleLine</span><span class="o">*</span><span class="p">,</span> <span class="n">title</span><span class="o">*</span><span class="p">:</span> <span class="kt">string</span>
        <span class="n">props</span><span class="o">*</span> <span class="p">:</span> <span class="n">Table</span><span class="o">[</span><span class="kt">string</span><span class="p">,</span> <span class="n">Property</span><span class="o">]</span>

<span class="k">method</span> <span class="n">addItem</span><span class="p">(</span><span class="n">this</span><span class="p">:</span> <span class="n">Property</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="kt">string</span><span class="p">)</span> <span class="o">=</span>
    <span class="n">this</span><span class="p">.</span><span class="n">items</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
</pre></div></div>
<p>As our parsing will depend on the indentation level we can use this handy function to get the indentation level of a line (number of spaces before the first asciiLetter)</p>
<div class="code"><div class="highlight"><pre><span></span><span class="k">proc </span><span class="nf">getIndentLevel</span><span class="p">(</span><span class="n">line</span><span class="p">:</span> <span class="kt">string</span><span class="p">)</span> <span class="p">:</span> <span class="kt">int</span> <span class="o">=</span> 
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">c</span><span class="p">.</span><span class="n">isSpaceAscii</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">i</span>
    <span class="k">return</span> <span class="mi">0</span>
</pre></div></div>
<p>It’d have been nicer to use <code>takewhile</code>, but it’s not available in nim stdlib
</p><div class="code"><div class="highlight"><pre><span></span>    <span class="n">getindentlevel</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">l</span><span class="p">:</span>  <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">takewhile</span><span class="p">(</span><span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="n">c</span><span class="o">.</span><span class="n">isspace</span><span class="p">(),</span> <span class="n">l</span><span class="p">)))</span>
</pre></div></div>
</div>
<div id="uid13" data-tralics-id="uid13" class="subsection" data-number="1.2.4"><h3><a href="day1_dmidecode_fragment.html#uid13" class="heading hyperref"><span class="number">1.2.4 </span>Parsing DMI source into nim structures</a></h3>
<p class="noindent">There’re many ways to parse the DMI (e.g using regex which would be fairly simple “feel free to implement it” and kindly send me a PR to update this tutorial)
</p><div class="code"><div class="highlight"><pre><span></span>proc parseDMI* (source: string) : Table[string, Section]=
</pre></div></div>
<p>In plain english for output like this
</p><div class="code"><div class="highlight"><pre><span></span>Getting SMBIOS data from sysfs.
SMBIOS 2.6 present.

Handle 0x0000, DMI type 0, 24 bytes
BIOS Information
        Vendor: LENOVO
        Version: 29CN40WW(V2.17)
        Release Date: 04/13/2011
        ROM Size: 2048 kB
        Characteristics:
                PCI is supported
                BIOS is upgradeable
                BIOS shadowing is allowed
                Boot from CD is supported
                Selectable boot is supported
                EDD is supported
                Japanese floppy for NEC 9800 1.2 MB is supported (int 13h)
                Japanese floppy for Toshiba 1.2 MB is supported (int 13h)
                5.25"/360 kB floppy services are supported (int 13h)
                5.25"/1.2 MB floppy services are supported (int 13h)
                3.5"/720 kB floppy services are supported (int 13h)
                3.5"/2.88 MB floppy services are supported (int 13h)
                8042 keyboard services are supported (int 9h)
                CGA/mono video services are supported (int 10h)
                ACPI is supported
                USB legacy is supported
                BIOS boot specification is supported
                Targeted content distribution is supported
        BIOS Revision: 1.40
</pre></div></div>
<p>we have couple of states
</p><div class="code"><div class="highlight"><pre><span></span><span class="k">type</span> 
    <span class="n">ParserState</span> <span class="o">=</span> <span class="k">enum</span>
        <span class="n">noOp</span><span class="p">,</span> <span class="n">sectionName</span><span class="p">,</span> <span class="n">readKeyValue</span><span class="p">,</span> <span class="n">readList</span>
</pre></div></div>
<ul>
<li>noOp: no action yet
</li>
<li>sectionName: read sectionName
</li>
<li>readKeyValue: read a line has colon <code>:</code> in it into a key value pair
</li>
<li>readList: when the next line has greater indentation level than the property line
</li></ul>
<p>so our state is noOp until we reach line
<code>Handle 0x0000, DMI type 0, 24 bytes</code>
then moves to sectionName</p>
<p>for line <code>BIOS Information</code> then state changes to reading properties
</p><div class="code"><div class="highlight"><pre><span></span>        Vendor: LENOVO
        Version: 29CN40WW(V2.17)
        Release Date: 04/13/2011
        ROM Size: 2048 kB
        Characteristics:
</pre></div></div>
<p>then we notice the indentation on the next line is greater than the one on the current line
</p><div class="code"><div class="highlight"><pre><span></span>                PCI is supported
        Characteristics:
</pre></div></div>
<p>so state moves into readList to read the items related to property <code>Characterstics</code>
</p><div class="code"><div class="highlight"><pre><span></span>                PCI is supported
                BIOS is upgradeable
                BIOS shadowing is allowed
                Boot from CD is supported
                Selectable boot is supported
                EDD is supported
                Japanese floppy for NEC 9800 1.2 MB is supported (int 13h)
                Japanese floppy for Toshiba 1.2 MB is supported (int 13h)
                5.25"/360 kB floppy services are supported (int 13h)
                5.25"/1.2 MB floppy services are supported (int 13h)
                3.5"/720 kB floppy services are supported (int 13h)
                3.5"/2.88 MB floppy services are supported (int 13h)
                8042 keyboard services are supported (int 9h)
                CGA/mono video services are supported (int 10h)
                ACPI is supported
                USB legacy is supported
                BIOS boot specification is supported
                Targeted content distribution is supported
</pre></div></div>
<p>and again it notices the indentation is of the next line is less than the current line
</p><div class="code"><div class="highlight"><pre><span></span>        BIOS Revision: 1.40
                Targeted content distribution is supported
</pre></div></div>
<p>so state switches again into <code>readKeyValue</code></p>
<ul>
<li>if we encounter an empty line:
<ul>
<li>if not in parsing state then it’s a noOp we ignore meta and empty lines
</li>
<li>if in parsing state <code>current Section isn’t nil</code> we finish parsing the section object
</li></ul>
</li></ul>
<div class="code"><div class="highlight"><pre><span></span><span class="k">proc </span><span class="nf">parseDMI</span><span class="o">*</span> <span class="p">(</span><span class="n">source</span><span class="p">:</span> <span class="kt">string</span><span class="p">)</span> <span class="p">:</span> <span class="n">Table</span><span class="o">[</span><span class="kt">string</span><span class="p">,</span> <span class="n">Section</span><span class="o">]=</span>
    
    <span class="kd">var</span>
        <span class="n">state</span> <span class="p">:</span> <span class="n">ParserState</span> <span class="o">=</span> <span class="n">noOp</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">strutils</span><span class="p">.</span><span class="n">splitLines</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
        <span class="n">sects</span> <span class="o">=</span> <span class="n">initTable</span><span class="o">[</span><span class="kt">string</span><span class="p">,</span> <span class="n">Section</span><span class="o">]</span><span class="p">()</span>
        
        <span class="n">p</span><span class="p">:</span> <span class="n">Property</span> <span class="o">=</span> <span class="kp">nil</span>
        <span class="n">s</span><span class="p">:</span> <span class="n">Section</span> <span class="o">=</span> <span class="kp">nil</span> 
        <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="kt">string</span>
</pre></div></div>
<p>Here we define the current state, code lines, initialize a table <code>sects</code> from <code>sectionName</code> to <code>Section Object</code> and variables p <code>current property</code>, s <code>current section</code>, k, v <code>current property key, value</code></p>
<div class="code"><div class="highlight"><pre><span></span>    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">(</span><span class="n">lines</span><span class="p">):</span>
</pre></div></div>
<p>Start looping on index, line using <code>pairs</code>
&gt; pairs is kinda like enumerate in python</p>
<div class="code"><div class="highlight"><pre><span></span>        <span class="k">if</span> <span class="n">l</span><span class="p">.</span><span class="n">startsWith</span><span class="p">(</span><span class="s">"Handle"</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Section</span>
            <span class="n">s</span><span class="p">.</span><span class="n">props</span> <span class="o">=</span> <span class="n">initTable</span><span class="o">[</span><span class="kt">string</span><span class="p">,</span> <span class="n">Property</span><span class="o">]</span><span class="p">()</span>
            <span class="n">s</span><span class="p">.</span><span class="n">handleline</span> <span class="o">=</span> <span class="n">l</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">sectionName</span>
            <span class="k">continue</span> 
</pre></div></div>
<p>If we encounter the string <code>Handle</code>
- create new section object and initialize it’s props table
- keep track of the handle line
- switch state to reading sectionName
- continue the loop to move to the title line</p>
<div class="code"><div class="highlight"><pre><span></span>        <span class="k">if</span> <span class="n">l</span> <span class="o">==</span> <span class="s">""</span><span class="p">:</span> <span class="c"># can be just new line before reading any sections. </span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">!=</span> <span class="kp">nil</span><span class="p">:</span>
                <span class="n">sects</span><span class="o">[</span><span class="n">s</span><span class="p">.</span><span class="n">title</span><span class="o">]</span> <span class="o">=</span> <span class="n">s</span>
            <span class="k">continue</span>
</pre></div></div>
<p>if line is empty and we have a section object <code>not nil</code> we finish the section and continue</p>
<div class="code"><div class="highlight"><pre><span></span>        <span class="k">if</span> <span class="n">state</span> <span class="o">==</span> <span class="n">sectionName</span><span class="p">:</span>  <span class="c"># current line is the title line</span>
            <span class="n">s</span><span class="p">.</span><span class="n">title</span> <span class="o">=</span> <span class="n">l</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">readKeyValue</span>  <span class="c"># change state into reading key value pairs</span>
</pre></div></div>
<p>If state is sectionName:
- this line is a title line
- change state for the upcoming to readKeyValue</p>
<div class="code"><div class="highlight"><pre><span></span>        <span class="k">elif</span> <span class="n">state</span> <span class="o">==</span> <span class="n">readKeyValue</span><span class="p">:</span>
            <span class="k">let</span> <span class="n">pair</span> <span class="o">=</span> <span class="n">l</span><span class="p">.</span><span class="n">split</span><span class="p">({</span><span class="sc">':'</span><span class="p">})</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">pair</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="p">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">len</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">pair</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>                 <span class="c"># value can be empty</span>
                <span class="n">v</span> <span class="o">=</span> <span class="s">""</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">Property</span><span class="p">(</span><span class="n">val</span><span class="p">:</span> <span class="n">v</span><span class="p">)</span>
            <span class="n">p</span><span class="p">.</span><span class="n">items</span> <span class="o">=</span> <span class="n">newSeq</span><span class="o">[</span><span class="kt">string</span><span class="o">]</span><span class="p">()</span>
            <span class="n">p</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">v</span>
</pre></div></div>
<p>If state is readKeyValue
- split the line on colon <code>:</code> to get key, value pair and set v to “” if not present
- make current Property <code>p</code> and initialize its related fields <code>items</code>, <code>val</code></p>
<div class="code"><div class="highlight"><pre><span></span>            <span class="c"># current line indentation is &lt;  nextline indentation =&gt; change state to readList</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">getIndentlevel</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">getIndentlevel</span><span class="p">(</span><span class="n">lines</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span><span class="p">))</span> <span class="p">:</span>
                <span class="n">state</span> <span class="o">=</span> <span class="n">readList</span>
</pre></div></div>
<p>If the next line indentation is greater this means we’re should be reading list of items regarding the current property <code>p</code></p>
<div class="code"><div class="highlight"><pre><span></span>            <span class="k">else</span><span class="p">:</span>
                <span class="c"># add key/value pair directly</span>
                <span class="n">s</span><span class="p">.</span><span class="n">props</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">p</span>
</pre></div></div>
<p>If not finish the property</p>
<div class="code"><div class="highlight"><pre><span></span>        <span class="k">elif</span> <span class="n">state</span> <span class="o">==</span> <span class="n">readList</span><span class="p">:</span>
            <span class="c"># keep adding the current line to current property items and if dedented =&gt; change state to readKeyValue</span>
            <span class="n">p</span><span class="p">.</span><span class="n">add_item</span><span class="p">(</span><span class="n">l</span><span class="p">.</span><span class="n">strip</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">getindentlevel</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">getindentlevel</span><span class="p">(</span><span class="n">lines</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span><span class="p">):</span>
                <span class="n">state</span> <span class="o">=</span> <span class="n">readKeyValue</span> 
                <span class="n">s</span><span class="p">.</span><span class="n">props</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">p</span>
</pre></div></div>
<p>if state is <code>readList</code>
- keep adding items to current property <code>p</code>
- if the indentation level decreased change state to <code>readKeyValue</code> and finish property
</p><div class="code"><div class="highlight"><pre><span></span>    return sects
</pre></div></div>
</div></div>